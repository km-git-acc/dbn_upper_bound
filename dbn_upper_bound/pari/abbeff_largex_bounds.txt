\\memoize.gp is available from https://download.tuxfamily.org/user42/pari/memoize.gp
\\read("memoize.gp");

subsets(A, k) = {
   my (lst = List());
   forvec(v = vector(k, i, [1, #A]), listput(lst, vecextract(A, v)), 2);
   return(Vec(lst));
};

position = (elt, array) -> select((x) -> x == elt, array, 1)[1];

bt(n,t) = n^((t/4)*log(n));
at(n,t,y,commonterm=1) = commonterm*n^(y+(t/4)*log(n));
alpha1(s) = 1/(2*s) + 1/(s-1) + (1/2)*log(s/(2*Pi));

divdelta(n,d) = if(n%d==0,1,0);
threshdelta(n,dN) = if(n<=dN,1,0);
combdelta(n,divisor,N) = divdelta(n,divisor)*threshdelta(n,divisor*N);

mollifier(mtype,t)={
if(mtype==1, return(List([1,1,[1],[1]])));
if(mtype>=2,\
np = position(mtype,primes(200));
p = primes(np); mollp = vector(np,i,bt(p[i],t));
divsubs = []; mollsubs=[];
for(i=1,np, divsubs=concat(divsubs,subsets(p,i)); mollsubs=concat(mollsubs,subsets(mollp,i)));
d = vector(length(divsubs),j,prod(k=1,length(divsubs[j]),divsubs[j][k]));
moll = vector(length(mollsubs),j,(-1)^length(mollsubs[j])*prod(k=1,length(mollsubs[j]),mollsubs[j][k]));
d=concat([1],d); moll=concat([1],moll); 
ndivs = length(d); D = d[ndivs];
return(List([D,ndivs,d,moll]));\
);
}

mollifier_prime(mtype,t)={
if(mtype==1, return(List([1,1,[1],[1]])));
if(mtype>=2,\
np = position(mtype,primes(200));
p = primes(np); mollp = vector(np,i,bt(p[i],t));
divsubs = []; mollsubs=[];
divsubs=concat(divsubs,subsets(p,1)); mollsubs=concat(mollsubs,subsets(mollp,1));
d = vector(length(divsubs),j,prod(k=1,length(divsubs[j]),divsubs[j][k]));
moll = vector(length(mollsubs),j,(-1)^length(mollsubs[j])*prod(k=1,length(mollsubs[j]),mollsubs[j][k]));
d=concat([1],d); moll=concat([1],moll); 
ndivs = length(d); D = d[ndivs];
return(List([D,ndivs,d,moll]));\
);
}

bound_constants(N,y,t) = {
xN = 4*Pi*N^2 - Pi*t/4;
xNp1 = 4*Pi*(N+1)^2 - Pi*t/4;
sig = (1+y)/2 + (t/4)*log(xN/(4*Pi)) - (t/(2*xN^2))*max(0,1 - 3*y + 4*y*(1+y)/xN^2);
K = t/2*(alpha1((1-y+I*xN)/2) - alpha1((1+y+I*xN)/2));
ReK = real(K);
modK = t*y/(2*(xN-6));
yK = y - conj(K);
modgamma = exp(0.02*y)*(xN/(4*Pi))^(-y/2);
return(List([xN,xNp1,sig,K,ReK,modK,yK,modgamma]));
}

b_tbound(N,t,carr,mollarr) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];  
sig = carr[3];
return(sum(n=1,D*N,abs(sum(nd=1,ndivs,if(combdelta(n,d[nd],N)>0,moll[nd]*bt(n/d[nd],t))))/n^sig));
}

a_tbound(N,t,carr,mollarr) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
sig = carr[3]; yK = carr[7];
return(sum(n=1,D*N,abs(sum(nd=1,ndivs,if(combdelta(n,d[nd],N)>0,moll[nd]*at(n/d[nd],t,yK,1))))/n^sig));
}

b_tbound_approx(N,y,t,carr,mollarr) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
sig = carr[3]; 
sigb = (1+y)/2;
main_sum = sum(n=1,N,abs(sum(nd=1,ndivs,if(combdelta(n,d[nd],N)>0,moll[nd]*bt(n/d[nd],t))))/n^sig);
tail_sum = sum(nd=2,ndivs,(abs(moll[nd])*bt(d[nd],t)/N^((t/2)*log(d[nd])))*(N^(1-sigb-(t/4)*log(N))+(d[nd]*N)^(1-sigb-(t/4)*log(N/d[nd])))*log(d[nd])/d[nd]/2); 
\\print(main_sum);print(tail_sum);
return(main_sum+tail_sum);
}

a_tbound_approx(N,y,t,carr,mollarr) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
sig = carr[3]; yK = carr[7];
siga = (1-y)/2;
main_sum = sum(n=1,N,abs(sum(nd=1,ndivs,if(combdelta(n,d[nd],N)>0,moll[nd]*at(n/d[nd],t,yK,1))))/n^sig);
tail_sum = sum(nd=2,ndivs,(abs(moll[nd])*bt(d[nd],t)/(d[nd]^y*N^((t/2)*log(d[nd]))))*(N^(1-siga-(t/4)*log(N))+(d[nd]*N)^(1-siga-(t/4)*log(N/d[nd])))*log(d[nd])/d[nd]/2);
\\print(main_sum);print(tail_sum);
return(main_sum+tail_sum);
}

lembound(N,y,t,carr,mollarr) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
sig = carr[3]; modgamma = carr[8]; modK=carr[6];
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
a1 = at(1,t,y);
common = (1-modgamma*a1)/(1+modgamma*a1);
b = vector(D*N-1,n,sum(nd=1,ndivs,if(combdelta(n+1,d[nd],N)>0,moll[nd]*bt((n+1)/d[nd],t))));
a = modgamma*vector(D*N-1,n,sum(nd=1,ndivs,if(combdelta(n+1,d[nd],N)>0,moll[nd]*at((n+1)/d[nd],t,y))));
lbound = 1 - modgamma*a1 - sum(n=1,D*N-1,max(abs(b[n]-a[n]),common*abs(b[n]+a[n]))/(n+1)^sig) - modmoll*modgamma*sum(n=1,N,bt(n,t)*(n^modK-1)/n^(sig-y));return(lbound);
}

lembound_approx(N,y,t,carr,mollarr) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
sig = carr[3]; modgamma = carr[8]; modK=carr[6];
sigb = (1+y)/2; siga = (1-y)/2;
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
a1 = at(1,t,y);
common = (1-modgamma*a1)/(1+modgamma*a1);
b = vector(N-1,n,sum(nd=1,ndivs,if(combdelta(n+1,d[nd],N)>0,moll[nd]*bt((n+1)/d[nd],t))));
a = modgamma*vector(N-1,n,sum(nd=1,ndivs,if(combdelta(n+1,d[nd],N)>0,moll[nd]*at((n+1)/d[nd],t,y))));
lbound = 1 - modgamma*a1 - sum(n=1,N-1,max(abs(b[n]-a[n]),common*abs(b[n]+a[n]))/(n+1)^sig) - modmoll*modgamma*sum(n=1,N,bt(n,t)*(n^modK-1)/n^(sig-y));
tail_sumb = sum(nd=2,ndivs,(abs(moll[nd])*bt(d[nd],t)/N^((t/2)*log(d[nd])))*(N^(1-sigb-(t/4)*log(N))+(d[nd]*N)^(1-sigb-(t/4)*log(N/d[nd])))*log(d[nd])/d[nd]/2); 
tail_suma = sum(nd=2,ndivs,(abs(moll[nd])*bt(d[nd],t)/(d[nd]^y*N^((t/2)*log(d[nd]))))*(N^(1-siga-(t/4)*log(N))+(d[nd]*N)^(1-siga-(t/4)*log(N/d[nd])))*log(d[nd])/d[nd]/2); 
\\print(lbound);print(tail_sumb);print(tail_suma);
lbound = lbound - tail_sumb - modgamma*tail_suma;
return(lbound);
}

\\divdelta = memoize(divdelta);
\\regdelta = memoize(regdelta);
\\bt = memoize(bt);
\\at = memoize(at);
\\mollifier = memoize(mollifier);

abbeff_largex_ep_tbound(N,y,t,mtype=1)={
carr = bound_constants(N,y,t);
mollarr = mollifier(mtype,t);
modgamma = carr[8];
best = b_tbound(N,t,carr,mollarr);
aest = a_tbound(N,t,carr,mollarr);
lbound = 2 - best - modgamma*aest;
\\print(best);print(aest);print(lbound);
return(lbound);
}

abbeff_largex_ep_tbound_mollp(N,y,t,mtype=1)={
carr = bound_constants(N,y,t);
mollarr = mollifier_prime(mtype,t);
modgamma = carr[8];
best = b_tbound(N,t,carr,mollarr);
aest = a_tbound(N,t,carr,mollarr);
lbound = 2 - best - modgamma*aest;
\\print(best);print(aest);print(lbound);
return(lbound);
}

abbeff_largex_ep_tbound_approx(N,y,t,mtype=1)={
carr = bound_constants(N,y,t);
mollarr = mollifier_prime(mtype,t);
\\mollarr = mollifier(mtype);
modgamma = carr[8];
best = b_tbound_approx(N,y,t,carr,mollarr);
aest = a_tbound_approx(N,y,t,carr,mollarr);
lbound = 2 - best - modgamma*aest;
\\print(best);print(aest);print(lbound);
return(lbound);
}

abbeff_largex_ep_lbound(N,y,t,mtype=1)={
carr = bound_constants(N,y,t);
mollarr = mollifier(mtype,t);
lbound = lembound(N,y,t,carr,mollarr);
return(lbound);
}

abbeff_largex_ep_lbound_mollp(N,y,t,mtype=1)={
carr = bound_constants(N,y,t);
mollarr = mollifier_prime(mtype,t);
lbound = lembound(N,y,t,carr,mollarr);
return(lbound);
}

abbeff_largex_ep_lbound_approx(N,y,t,mtype=1)={
carr = bound_constants(N,y,t);
mollarr = mollifier_prime(mtype,t);
\\mollarr = mollifier(mtype);
lbound = lembound_approx(N,y,t,carr,mollarr);
return(lbound);
}

abbeff_largex_ep_tbound_sawtooth(prevbound,nextN,y,t,mtype=1)={
carr = bound_constants(nextN,y,t);
modgamma = carr[8]; sig = carr[3]; yK = carr[7];
mollarr = mollifier(mtype,t);
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
offset = D*(nextN-1);
b_part = sum(n=offset+1,offset+D,abs(sum(nd=1,ndivs,if(combdelta(n,d[nd],nextN)>0,moll[nd]*bt(n/d[nd],t))))/n^sig);
a_part = sum(n=offset+1,offset+D,abs(sum(nd=1,ndivs,if(combdelta(n,d[nd],nextN)>0,moll[nd]*at(n/d[nd],t,yK,1))))/n^sig);
lbound = prevbound - b_part - modgamma*a_part;
return(lbound);
}

abbeff_largex_ep_lbound_sawtooth(prevbound,nextN,y,t,mtype=1)={
carr = bound_constants(nextN,y,t);
modgamma = carr[8]; sig = carr[3]; modK=carr[6]; yK = carr[7];
mollarr = mollifier(mtype,t);
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
a1 = at(1,t,y);
common = (1-modgamma*a1)/(1+modgamma*a1);
offset = D*(nextN-1);
b = vector(D,n,sum(nd=1,ndivs,if(combdelta(n+offset,d[nd],nextN)>0,moll[nd]*bt((n+offset)/d[nd],t))));
a = modgamma*vector(D,n,sum(nd=1,ndivs,if(combdelta(n+offset,d[nd],nextN)>0,moll[nd]*at((n+offset)/d[nd],t,y))));
lbound = prevbound - sum(n=1,D,max(abs(b[n]-a[n]),common*abs(b[n]+a[n]))/(n+offset)^sig) - modmoll*modgamma*bt(nextN,t)*(nextN^modK-1)/nextN^(sig-y);
return(lbound);
}

abbeff_largex_ep_lbound_sawtooth_loop(boundfile,initbound,Nstart,Nend,y,t,mtype=1)={
mollarr = mollifier(mtype,t);
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
a1 = at(1,t,y);
prevbound=initbound;

for(nextN=Nstart,Nend,\
carr = bound_constants(nextN,y,t);\
modgamma = carr[8]; sig = carr[3]; modK=carr[6];\
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
common = (1-modgamma*a1)/(1+modgamma*a1);\
offset = D*(nextN-1);\
b = vector(D,n,sum(nd=1,ndivs,if(combdelta(n+offset,d[nd],nextN)>0,moll[nd]*bt((n+offset)/d[nd],t))));\
a = modgamma*vector(D,n,sum(nd=1,ndivs,if(combdelta(n+offset,d[nd],nextN)>0,moll[nd]*at((n+offset)/d[nd],t,y))));\
lbound = prevbound - sum(n=1,D,max(abs(b[n]-a[n]),common*abs(b[n]+a[n]))/(n+offset)^sig) - modmoll*modgamma*bt(nextN,t)*(nextN^modK-1)/nextN^(sig-y);\
row = [t,y,nextN,lbound];\
print(row); write(boundfile,row);\
prevbound=lbound;\
);
}

lembound_conservative(N,y,t,carr,mollarr,common) = {
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
sig = carr[3]; modgamma = carr[8]; modK=carr[6];
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
a1 = at(1,t,y);
b = vector(D*N-1,n,sum(nd=1,ndivs,if(combdelta(n+1,d[nd],N)>0,moll[nd]*bt((n+1)/d[nd],t))));
a = modgamma*vector(D*N-1,n,sum(nd=1,ndivs,if(combdelta(n+1,d[nd],N)>0,moll[nd]*at((n+1)/d[nd],t,y))));
lbound = 1 - modgamma*a1 - sum(n=1,D*N-1,max(abs(b[n]-a[n]),common*abs(b[n]+a[n]))/(n+1)^sig) - modmoll*modgamma*sum(n=1,N,bt(n,t)*(n^modK-1)/n^(sig-y));return(lbound);
}

abbeff_largex_ep_lbound_conservative(N,Nend,y,t,mtype=1)={
carr = bound_constants(N,y,t);
modgamend = bound_constants(Nend,y,t)[8];
common = (1-modgamend)/(1+modgamend);
mollarr = mollifier(mtype,t);
lbound = lembound_conservative(N,y,t,carr,mollarr,common);
return(lbound);
}

abbeff_largex_ep_lbound_sawtooth_conservative_loop(boundfile,initbound,Nstart,Nend,y,t,mtype=1)={
mollarr = mollifier(mtype,t);
D = mollarr[1]; ndivs = mollarr[2]; d = mollarr[3]; moll = mollarr[4];
a1 = at(1,t,y);
modgamend = bound_constants(Nend,y,t)[8];\
common = (1-modgamend*a1)/(1+modgamend*a1);\
prevbound=initbound;

for(nextN=Nstart,Nend,\
carr = bound_constants(nextN,y,t);\
modgamma = carr[8]; sig = carr[3]; modK=carr[6];\
modmoll = sum(nd=1,ndivs,abs(moll[nd])/d[nd]^sig);
offset = D*(nextN-1);\
b = vector(D,n,sum(nd=1,ndivs,if(combdelta(n+offset,d[nd],nextN)>0,moll[nd]*bt((n+offset)/d[nd],t))));\
a = modgamma*vector(D,n,sum(nd=1,ndivs,if(combdelta(n+offset,d[nd],nextN)>0,moll[nd]*at((n+offset)/d[nd],t,y))));\
lbound = prevbound - sum(n=1,D,max(abs(b[n]-a[n]),common*abs(b[n]+a[n]))/(n+offset)^sig) - modmoll*modgamma*bt(nextN,t)*(nextN^modK-1)/nextN^(sig-y);\
row = [t,y,nextN,lbound];\
print(row); write(boundfile,row);\
prevbound=lbound;\
);
}

abbeff_largex_bound(N,y,t,N0=2000)={
\\based on older bound but can provide a bound estimate for arbitrarily large N
N0 = if(N<N0,N,N0); 
xN = 4*Pi*N^2 - Pi*t/4;
xNp1 = 4*Pi*(N+1)^2 - Pi*t/4;
delta = Pi*y/(2*(xN - 6 - (14 + 2*y)/Pi)) + 2*y*(7+y)*log(abs(1+y+I*xNp1)/(4*Pi))/xN^2;
afac = exp(delta + t*y*log(N)/(2*(xN-6)))/N^y;
sigb = (1+y)/2;
siga = (1-y)/2;
sb = sigb + (t/2)*log(N);
sa = siga + (t/2)*log(N);
bbound = sum(n=1,N0,bt(n,t)/n^sb) + max(N0^(1-sigb-(t/4)*log(N^2/N0)),N^(1-sigb-(t/4)*log(N)))*log(N/N0);
abound = sum(n=1,N0,bt(n,t)/n^sa) + max(N0^(1-siga-(t/4)*log(N^2/N0)),N^(1-siga-(t/4)*log(N)))*log(N/N0);
lbound = 2 - (bbound + afac*abound);
return(lbound);
}

\\example usage 1
thresh=0.02;
y=0.2;t=0.2;mtype=5;
N=69098;
\\bound = abbeff_largex_ep_lbound(N,y,t,mtype);
bound = 0.0699020198333475;

while(bound>=thresh,\
N=N+1;\
bound = abbeff_largex_ep_lbound_sawtooth(bound,N,y,t,mtype);\
print(List([t,y,N,bound]));\
);

\\example usage 2
N=69098;y=0.2;t=0.2;mtype=7;
Nstart=N+1;
Nend=1.5*10^6;
\\initbound = abbeff_largex_ep_lbound_conservative(N,Nend,y,t,mtype);
initbound = 0.0338943569372946644;

boundfile="N_69098_to_1.5mil_y_0.2_t_0.2_moll_euler5_sawtooth_lemmabounds_conservative.txt";
abbeff_largex_ep_lbound_sawtooth_conservative_loop(boundfile,initbound,Nstart,Nend,y,t,mtype);

