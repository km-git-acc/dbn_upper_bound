default(realprecision, 30);
default(parisizemax,3*10^9);

printm(M)=apply(s->print(s),Col(M));print1();

factorial_divide(val,n)={
while(n>1,val=val/n;n=n-1);
return(val);
}

bt(n,t)=return(n^((t/4)*log(n)));
alpha1(s) = 1/(2*s) + 1/(s-1) + (1/2)*log(s/(2*Pi));
alpha1prime(s) = -1/(2*s^2) - 1/(s-1)^2 + 1/(2*s);
H01(s) = (1/2)*s*(s-1)*Pi^(-s/2)*sqrt(2*Pi)*exp((s/2-1/2)*log(s/2)-s/2);
C0(p) = (exp(Pi*I*(p^2/2 + 3/8)) - I*sqrt(2)*cos(Pi*p/2))/(2*cos(Pi*p));
B0_eff(x,y,t) = (1/8)*exp((t/4)*alpha1((1+y-I*x)/2)^2)*H01((1+y-I*x)/2);

abbeff(x,y,t) = {       
    s = (1 - y + I*x)/2; 
    N = floor(sqrt((x+Pi*t/4)/(4*Pi)));
    alph1 = alpha1(s);
    alph2 = alpha1(1-s);
    A0 = (1/8)*exp((t/4)*alph1^2)*H01(s);
    B0 = (1/8)*exp((t/4)*alph2^2)*H01(1-s);
    A_sum = sum(n=1,N,n^((t/4.0)*log(n) - (t/2.0)*alph1 - s));
    B_sum = sum(n=1,N,n^((t/4.0)*log(n) - (t/2.0)*alph2 - (1-s)));
    A = A0 * A_sum;
    B = B0 * B_sum;
    return ((A+B)/B0);
}

ddx_abbeff_Nbound(N,y,t)={
xN = 4*Pi*N^2 - Pi*t/4;
xNp1 = 4*Pi*(N+1)^2 - Pi*t/4;
sig = (1+y)/2 + (t/4)*log(xN/(4*Pi)) - (t/(2*xN^2))*max(0,1 - 3*y + 4*y*(1+y)/xN^2);
K = t/2*(alpha1((1-y+I*xN)/2) - alpha1((1+y+I*xN)/2));
ReK = real(K);
modK = t*y/(2*(xN-6));
yK = y - conj(K);
modgamma = exp(0.02*y)*(xN/(4*Pi))^(-y/2);

ddxbound_sumb = sum(n=1,N,bt(n,t)*((t/4)*log(n)/(xN-6) + log(n)/2)/n^sig);
ddxbound_suma = sum(n=1,N,bt(n,t)*(n^y)*((t/4)*log(n)/(xN-6) + (log(abs(1+y+I*xNp1)/(4*Pi)) + Pi + 3/xN)*((t/4)/(xN-6) + 1/2))/n^sig);
ddxbound = ddxbound_sumb + modgamma*(N^modK)*ddxbound_suma;
return(ddxbound);
}

ddt_abbeff_Nbound(N,y,t)={
xN = 4*Pi*N^2 - Pi*t/4;
xNp1 = 4*Pi*(N+1)^2 - Pi*t/4;
sig = (1+y)/2 + (t/4)*log(xN/(4*Pi)) - (t/(2*xN^2))*max(0,1 - 3*y + 4*y*(1+y)/xN^2);
K = t/2*(alpha1((1-y+I*xN)/2) - alpha1((1+y+I*xN)/2));
ReK = real(K);
modK = t*y/(2*(xN-6));
yK = y - conj(K);
modgamma = exp(0.02*y)*(xN/(4*Pi))^(-y/2);

ddtb_sumb = sum(n=1,N,bt(n,t)*((1/4)*log(n)*log(xNp1/(4*Pi*n)) + (Pi/8)*log(n) + 2*log(n)/(xN-6))/n^sig);
ddtb_suma = sum(n=1,N,bt(n,t)*(n^y)*((1/4)*log(n)*log(xNp1/(4*Pi*n)) + (Pi/8)*log(n) + 2*log(n)/(xN-6) + (1/4)*(Pi/2 + 8/(xN-6))*(log(xNp1/(4*Pi)) + 8/(xN-6)))/n^sig);
ddtbound = ddtb_sumb + modgamma*(N^modK)*ddtb_suma;
return(ddtbound);
}

polyevalx(poly,xval) = eval(poly);
polyevalt(poly,tval) = eval(poly);
polyevalz(poly,zval) = eval(poly);

\\begin polynomial stored sums approach
polyet(xval) = truncate(taylor(exp(zval*xval),zval))*truncate(taylor(exp(tval*xval^2/4),tval));

storedsumspoly(X,y) = {
N = floor(sqrt(X/(4*Pi)));
H=N; n0 = H/2;

X=X+1/2;y=(1+y)/2;
expob = (-1-y+I*X)/2; expoa = (-1+y-I*X)/2; 
polyab = sum(h=1,H,[h^expob,h^expoa]*polyet(log(h/n0)));
X=X-1/2;y=2*y-1;

return([n0,polyab[1],polyab[2]]);
}

abbapproxarrpoly(X,y,t,num,bexpo,aexpo,sarr,storedsumsdata)={
    n0 = storedsumsdata[1]; logtn0 = (t/2)*log(n0);
	polyb = storedsumsdata[2]; polybt = polyevalt(polyb,t); 
	polya = storedsumsdata[3]; polyat = polyevalt(polya,t);
	
    afac = vector(num,v,exp((t/4)*(alpha1(sarr[v])^2 - alpha1(1-sarr[v])^2))*H01(sarr[v])/H01(1-sarr[v]));
    bsums = vector(num,v,n0^(bexpo[v]+logtn0/2)*polyevalz(polybt,bexpo[v]+logtn0));
    asums = vector(num,v,n0^(aexpo[v]+logtn0/2)*polyevalz(polyat,aexpo[v]+logtn0));
    ests = vector(num,v,bsums[v]+afac[v]*asums[v]);
	return(ests);	
}
\\end polynomial stored sums approach

\\begin matrix stored sums approach
\\slow and accurate taylor vector
taylorvec(xval,nterms) = vector(nterms,n,factorial_divide(xval^(n-1),n-1));

\\fast but maybe less accurate taylor vector 
taylorvec(xval,nterms) = vector(nterms,n,xval^(n-1)/factorial(n-1));

\\faster and accurate taylor vector
taylorvec(xval,nterms) = {
resvec = vector(nterms);
resvec[1]=1; for(ctr=1,nterms-1,resvec[ctr+1] = resvec[ctr]*xval/ctr);
return(resvec);
}

matet(xval,expterms,ttaylorterms) = mattranspose(taylorvec(xval,expterms))*taylorvec(xval^2/4,ttaylorterms);

matsba(vecab,mat) = [vecab[1]*mat,vecab[2]*mat];

mattopolyt(mat,tval) = {
numrc = matsize(mat);
poly=0; for(i=1,numrc[1],for(j=1,numrc[2],poly = poly + mat[i,j]*tval^(j-1)*zval^(i-1)));
return(poly);
}

storedsums(X,y,expterms=50,ttaylorterms=40) = {
N = floor(sqrt(X/(4*Pi)));
H=N; n0 = H/2;

X=X+1/2;y=(1+y)/2;
expob = (-1-y+I*X)/2; expoa = (-1+y-I*X)/2; 
finalmats = sum(h=1,H,matsba([h^expob,h^expoa],matet(log(h/n0),expterms,ttaylorterms)));
X=X-1/2;y=2*y-1;

return([n0,finalmats[1],finalmats[2]]);
}

abbapproxarr(X,y,t,num,bexpo,aexpo,sarr,storedsumsdata)={
    n0 = storedsumsdata[1]; logtn0 = (t/2)*log(n0);
	matb = storedsumsdata[2]; polybt = mattopolyt(matb,t); 
	mata = storedsumsdata[3]; polyat = mattopolyt(mata,t);
	
    afac = vector(num,v,exp((t/4)*(alpha1(sarr[v])^2 - alpha1(1-sarr[v])^2))*H01(sarr[v])/H01(1-sarr[v]));
    bsums = vector(num,v,n0^(bexpo[v]+logtn0/2)*polyevalz(polybt,bexpo[v]+logtn0));
    asums = vector(num,v,n0^(aexpo[v]+logtn0/2)*polyevalz(polyat,aexpo[v]+logtn0));
    ests = vector(num,v,bsums[v]+afac[v]*asums[v]);
	return(ests);	
}
\\end matrix stored sums approach

abbeff_multieval_symmetric_rectangle(X,y,t,num=5,storedsumsdata)={
    X=X+1/2;y=(1+y)/2;
    N = floor(sqrt((X+Pi*t/4)/(4*Pi)));
    output = List();
    
    thtarr = vector(num,v,-1/2 + (v-1)/(num-1));
    zarr = vector(num,v,-(1-y) + 2*(1-y)*(v-1)/(num-1));
    sarr = vector(0); bexpo=vector(0);aexpo=vector(0);
	
    \\x lower constant
    sarr = concat(sarr,vector(num,v,(1-y+I*X-zarr[v]-I/2)/2));
    bexpo = concat(bexpo,vector(num,v,-(t/2)*alpha1(1-sarr[v]) - zarr[v]/2 - I/4));
    aexpo = concat(aexpo,vector(num,v,-(t/2)*alpha1(sarr[v]) + zarr[v]/2 + I/4));
    
    \\y upper constant
    sarr = concat(sarr,vector(num,v,(1-y+I*(X+thtarr[v])-(1-y))/2)); 
    bexpo = concat(bexpo,vector(num,v,-(t/2)*alpha1(1-sarr[v+num]) + I*thtarr[v]/2 - (1-y)/2));
    aexpo = concat(aexpo,vector(num,v,-(t/2)*alpha1(sarr[v+num]) - I*thtarr[v]/2 + (1-y)/2));
    
    \\x upper constant and output to be attached in reverse order
    sarr = concat(sarr,vector(num,v,(1-y+I*X-zarr[v]+I/2)/2));
    bexpo = concat(bexpo,vector(num,v,-(t/2)*alpha1(1-sarr[v+2*num]) - zarr[v]/2 + I/4));
    aexpo = concat(aexpo,vector(num,v,-(t/2)*alpha1(sarr[v+2*num]) + zarr[v]/2 - I/4));
    
    \\y lower constant and output to be attached in reverse order
    sarr = concat(sarr,vector(num,v,(1-y+I*(X+thtarr[v])+(1-y))/2));
    bexpo = concat(bexpo,vector(num,v,-(t/2)*alpha1(1-sarr[v+3*num]) + I*thtarr[v]/2 + (1-y)/2));
    aexpo = concat(aexpo,vector(num,v,-(t/2)*alpha1(sarr[v+3*num]) - I*thtarr[v]/2 - (1-y)/2));

    \\ests = abbapproxarrpoly(X,y,t,4*num,bexpo,aexpo,sarr,storedsumsdata);
	ests = abbapproxarr(X,y,t,4*num,bexpo,aexpo,sarr,storedsumsdata);
    for(idx=1,num-1,listput(output,List([t,y+zarr[idx]*1.0,X-1/2.0,ests[idx]])));
    for(idx=1,num-1,listput(output,List([t,y+(1-y),1.0*X+thtarr[idx]*1.0,ests[num+idx]])));
    for(idx=1,num-1,listput(output,List([t,y+zarr[num-idx+1]*1.0,X+1/2.0,ests[3*num-idx+1]])));
    for(idx=1,num-1,listput(output,List([t,y-(1-y),1.0*X+thtarr[num-idx+1]*1.0,ests[4*num-idx+1]])));

    X=X-1/2;y=2*y-1;
    return(output);
    }

\\test
\\X=10^10;y=0.2;t=0.2;num=3;expterms=50;ttaylorterms=40;
\\default(seriesprecision,max(expterms,ttaylorterms));
\\s=getwalltime();storedsumsdata = storedsums(X,y,expterms,ttaylorterms);e=getwalltime();print(e-s);
\\out = abbeff_multieval_symmetric_rectangle(X,y,t,num,storedsumsdata);
\\for(i=1,4*num-4,print([out[i][3],out[i][4]]));

detailsfile = "~/X_6_10pow10_plus_2099_y0_0.2_t_0.2_detailed_barrier_output_t_agnostic.csv";
summaryfile = "~/X_6_10pow10_plus_2099_y0_0.2_t_0.2_barrier_summary_t_agnostic.csv";
tstart=0.0; tend=0.2; X=6*10^10+2099; y0=0.2;
expterms = 50; ttaylorterms = 50; 

\\calculate polynomial stored sums
\\default(seriesprecision,max(expterms,ttaylorterms));
\\storedsumsdata = storedsumspoly(X,y0);
\\end calculate polynomial stored sums

\\calculate matrix stored sums
storedsumsdata = storedsums(X,y0,expterms,ttaylorterms);
\\end calculate matrix stored sums

N = floor(sqrt(X/(4*Pi)));
t=tstart;
counter=0;
while(t<=tend,{
\\timestart = getwalltime();
counter=counter+1;
if(Mod(counter,100)==1,Dtabb = ddt_abbeff_Nbound(N,y0,t); Dxabb = ddx_abbeff_Nbound(N,y0,t););
\\Dtabb = ddt_abbeff_Nbound(N,y0,0); Dxabb = ddx_abbeff_Nbound(N,y0,0);
sidemesh = ceil(Dxabb);
rectmesh = 4*sidemesh - 4;
minmodabb = 1000;
abbdata = abbeff_multieval_symmetric_rectangle(X,y0,t,sidemesh,storedsumsdata);

wind_num = sum(idx=1,rectmesh-1,arg(abbdata[idx][4]/abbdata[idx+1][4])) + arg(abbdata[rectmesh][4]/abbdata[1][4]);
for(i=1,rectmesh,write(detailsfile,abbdata[i]); modabb = abs(abbdata[i][4]); if(modabb<minmodabb,minmodabb=modabb));
wind_num = wind_num/(2*Pi);
\\timeend = getwalltime();
t_summary = List([t,Dtabb,Dxabb,wind_num,minmodabb,rectmesh]);
print(t_summary);
write(summaryfile,t_summary);
t = t + minmodabb/(2*Dtabb);
});
